# 農場ゲーム アプリケーション設計書

## 1. 概要

### 1.1. 目的
本ドキュメントは、「フラッター農場物語」の技術的なアーキテクチャ、データベース構造、および主要機能の実装方針を定義することを目的とする。

### 1.2. 技術スタック
- **フレームワーク**: Flutter
- **状態管理**: Riverpod
- **画面遷移**: GoRouter
- **データベース**: Drift (SQLiteをラップ)
- **その他**: http (将来的なAPI連携用), shared_preferences (軽量な設定保存用)

## 2. アーキテクチャ

アプリケーションは、教科書で学んだ内容を基盤とし、UI、状態管理、ビジネスロジック/データ層を明確に分離した、クリーンなアーキテクチャを採用する。

```mermaid
graph TD
    subgraph UI層
        A[画面 (Widgets)]
        B[アニメーション]
    end
    subgraph 状態管理層
        C[Riverpod (Providers)]
    end
    subgraph ロジック/データ層
        D[ビジネスロジック (Notifiers)]
        E[データベース (Drift)]
        F[外部API (http)]
    end

    A -- "イベントを通知" --> C
    C -- "状態を更新/ロジックを呼び出し" --> D
    C -- "状態をUIに反映" --> A
    D -- "データの読み書き" --> E
    D -- "外部と通信" --> F
```

- **UI層**: FlutterのWidgetで構築。ユーザーのアクションを状態管理層に通知し、状態の変化に応じてリアクティブにUIを更新する。
- **状態管理層**: Riverpodを全面的に採用。ゲームのグローバルな状態（時間、天候、プレイヤー情報など）や、各画面のUI状態をProviderとして管理する。
- **ロジック/データ層**:
  - ビジネスロジックは`StateNotifier`に集約し、UIから分離してテスト容易性を確保する。
  - 永続化データはすべてDriftを通じてローカルのSQLiteデータベースに保存する。

## 3. データベース設計 (Drift)

アプリケーション内に内包されるSQLiteデータベースを、Driftを通じて型安全に操作する。

### 3.1. テーブル定義

- **`player_states`**: プレイヤーの基本情報（単一レコード）
  - `id`: INTEGER (PRIMARY KEY)
  - `money`: INTEGER (所持金)
  - `stamina`: REAL (現在のスタミナ)
- **`inventory_items`**: プレイヤーの持ち物
  - `id`: INTEGER (PRIMARY KEY)
  - `item_code`: TEXT (アイテムを識別するコード)
  - `quantity`: INTEGER (所持数)
- **`farm_plots`**: 畑の区画の状態
  - `id`: INTEGER (PRIMARY KEY)
  - `x`: INTEGER (農場内のX座標)
  - `y`: INTEGER (農場内のY座標)
  - `crop_code`: TEXT (植えられている作物のコード)
  - `growth_stage`: INTEGER (成長段階)
  - `watered_at`: TEXT (最後に水をやった日付)
- **`animals`**: 飼育している動物
  - `id`: INTEGER (PRIMARY KEY)
  - `type_code`: TEXT (動物の種類を識別するコード)
  - `name`: TEXT (付けた名前)
  - `friendship`: INTEGER (なかよし度)
- **`item_definitions`**: アイテムの静的データ（図鑑用）
  - `code`: TEXT (PRIMARY KEY)
  - `name`: TEXT (名前)
  - `description`: TEXT (説明文)
  - `sell_price`: INTEGER (売値)
  - `item_type`: TEXT (CROP, FISH, DISHなど)

## 4. 主要機能の技術設計

### 4.1. ゲーム時間システム
- `TimeNotifier` (StateNotifier) を持つ `timeProvider` (StateNotifierProvider) を作成。
- `TimeNotifier`はゲーム内の「日」「季節」「時間」を状態として保持する。
- `Timer.periodic`を使い、現実世界の数秒ごとに`TimeNotifier`のメソッドを呼び出してゲーム内時間を進める。
- 時間が進むたび、`TimeNotifier`は他のNotifier（作物成長など）に影響を及ぼすイベントを発行する。

### 4.2. 栽培・収穫システム
- 農場は2Dグリッドとして管理する。
- プレイヤーがクワを使うと、対応するグリッドの`farm_plots`テーブルに新しいレコードが作成される。種まき、水やりでレコードが更新される。
- `TimeNotifier`からの日付変更イベントを受け、すべての`farm_plots`レコードをチェックし、条件（水やり済みかなど）に応じて`growth_stage`を更新するロジックを実装する。
- UIは`farm_plots`の状態を監視し、`growth_stage`に応じた作物のスプライトを表示する。

### 4.3. データ永続化
- ゲームのセーブは、プレイヤーがベッドで眠ったタイミングで実行する。
- 現在の各種状態（プレイヤー情報、インベントリ、畑の状態など）を管理する各Notifierから状態を取得し、Driftの`transaction`機能を使って、アトミックに（一括で安全に）データベースに書き込む。
- ゲームのロードは、アプリ起動時にデータベースからデータを読み込み、各Notifierの初期状態として設定する。
- ゲームの音量設定など、軽量な設定は`SharedPreferences`を使用する。

### 4.4. 画面遷移 (GoRouter)
- ルートパスを定義する。
  - `/`: メインのゲーム画面
  - `/shop`: 店画面
  - `/cooking`: 調理画面
  - `/map`: マップ画面
- メインのゲーム画面では、インベントリやメニュー表示のために`ShellRoute`（または他のネストされたナビゲーション）を使い、背景のゲーム画面を再描画することなくUIをオーバーレイ表示する。

## 5. UIとアニメーション
- プレイヤーキャラクターの移動や道具を振るアニメーションは、`AnimationController`とスプライトシートを使って実装する。
- アイテム入手時やレベルアップ時の通知は、`AnimatedOpacity`や`AnimatedPositioned`などの暗黙的アニメーションWidgetを使い、リッチなフィードバックを返す。
- スタミナバーや経験値バーなどのカスタムUIは、`CustomPainter`を使って描画する。
- 画面遷移には`Hero`アニメーションを積極的に採用し、UI要素がスムーズにつながる感覚を演出する。
