# Flutter教科書 - 上級編 - 3. パフォーマンス最適化 (農場たとえ話・増量版)

あなたの農場は、機能豊富で品質も保証されるようになりました。しかし、農場が大規模になるにつれ、「作業がなんだか重い」「トラクター（スクロール）がカクカクする」といった問題が出てくるかもしれません。この章では、農場の運営をよりスムーズで効率的にするための**「生産性改善（パフォーマンス最適化）」**の技術を学びます。

---

## 3.1 パフォーマンスの指標 ～農場の健康診断～

農場の生産性を測るには、いくつかの指標があります。

- **フレームレート (FPS - Frames Per Second)**: **農場の景色の滑らかさ**です。1秒間に60回景色が更新されれば（60FPS）、非常に滑らかに見えます。これが落ちると、景色がカクカクして見え、利用者は不快に感じます。Flutterの目標は、常に60FPSを維持することです。
- **UIスレッドとGPUスレッド**: Flutterには、主に2人の働き者がいます。
  - **UIスレッド**: `build`メソッドの実行など、Dartのコードを処理する**設計士**。
  - **GPUスレッド**: 設計士が作った設計図を元に、実際に画面にピクセルを描画する**現場監督**。
  設計士の仕事が重すぎると（重い`build`メソッド）、現場監督に設計図を渡すのが遅れ、結果的に景色がカクカクします（フレーム落ち）。
- **メモリ使用量**: **農場の作業スペースや倉庫の広さ**です。無駄な資材（オブジェクト）を倉庫に溜め込みすぎると、新しい作業スペースが確保できなくなり、農場全体の動きが鈍くなります。

これらの健康状態は、**Flutter DevTools**という高機能な診断ツールで詳細に監視・分析できます。

---

## 3.2 `build`メソッドのコストを削減する

パフォーマンス問題の多くは、**`build`メソッドの無駄な再実行や、重すぎる処理**が原因です。設計士（UIスレッド）の負担を減らすことが、最適化の第一歩です。

### `const`の活用: 変わらないものは作り置きする
`const`キーワードを付けてWidgetを生成すると、それは**「作り置きできる建築部品」**になります。`build`メソッドが何度呼ばれても、`const`の部品は再生成されず、以前に作ったものが再利用されます。これは、設計士が毎回同じ部品の設計図を描く手間を省く、非常に効果的な最適化です。

```dart
// 悪い例: 毎回新しい看板を作り直している
Scaffold(
  appBar: AppBar(
    title: Text('My Farm'), // buildのたびに再生成
  ),
  body: Padding(
    padding: EdgeInsets.all(8.0), // buildのたびに再生成
    child: Text('Welcome'),
  ),
);

// 良い例: 変わらない部品は作り置き(const)にする
Scaffold(
  appBar: AppBar(
    title: const Text('My Farm'), // const!
  ),
  body: const Padding( // const!
    padding: EdgeInsets.all(8.0),
    child: Text('Welcome'),
  ),
);
```
可能な限り`const`を付けることを、常に心がけましょう。

### `RepaintBoundary`: 独立したアトリエを与える
`AnimationController`で動く風車のように、頻繁に再描画されるWidgetがあると、その動きにつられて、周りの静的な建物まで毎回再描画されてしまうことがあります。

`RepaintBoundary`は、そのような**頻繁に動くWidgetに、独立したアトリエを与える**ようなものです。アトリエの中でどれだけ絵を描き直しても（再描画しても）、外の建物には影響を与えません。これにより、再描画の範囲を最小限に抑えることができます。

```dart
Column(
  children: [
    const Text('静的な建物'),
    // 風車に独立したアトリエを与える
    RepaintBoundary(
      child: Windmill(), // 内部で激しく再描画される
    ),
    const Text('これも静的な建物'),
  ],
)
```

### `setState`の影響範囲を限定する
`setState`を呼ぶと、そのWidget全体が再描画されます。状態変化に関係のない部分まで再描画するのは無駄です。

**状態を持つWidgetを、可能な限り小さく分割する**ことが重要です。農場全体を表す巨大な`StatefulWidget`を作るのではなく、「卵カウンター」「天気表示板」のように、役割ごとに小さな`StatefulWidget`（または`ConsumerWidget`）に分けましょう。これにより、`setState`やProviderによる再描画の影響範囲が、本当に必要な部分だけに限定されます。

---

## 3.3 リストのパフォーマンスを改善する

### `ListView.builder`の徹底
`ListView`を使う際は、必ず`ListView.builder`を使いましょう。これは、**「見える範囲の作物だけを植える」**という、リスト表示における最も基本的な最適化です（詳細は初級編3章を参照）。

### `itemExtent`の指定
もしリストの各項目がすべて同じ高さであることが分かっているなら、`itemExtent`プロパティを指定しましょう。

```dart
ListView.builder(
  itemCount: 1000,
  itemExtent: 80.0, // すべての項目の高さは80.0です、とFlutterに教える
  itemBuilder: (context, index) {
    // ...
  },
)
```
これにより、Flutterは**「これから表示する作物の背丈」**を事前に知ることができるため、スクロール先のレイアウト計算を大幅に簡略化でき、スクロール性能が向上します。

---

## 3.4 遅延読み込み (Lazy Loading)

アプリ起動時に、すべてのデータ（家畜リスト、収穫記録、設定など）を一度に読み込むのは、**農場を開ける前に、すべての倉庫の在庫を数え上げる**ようなもので、非常に時間がかかります。

**遅延読み込み**は、**「必要になった時に、初めて倉庫に見に行く」**という考え方です。
- **画像の遅延読み込み**: `cached_network_image`パッケージは、一度読み込んだ画像をキャッシュし、次回以降の表示を高速化します。また、リストで画像が表示される瞬間まで、読み込みを遅延させます。
- **データの遅延読み込み**: `ListView`で一番下までスクロールしたら、次のページのデータをAPIから読み込む（無限スクロール）などが、代表的な実装です。`FutureProvider`や`StreamProvider`を使い、ユーザーのアクションに応じてデータを取得するように設計します。

---

### まとめ

この章では、農場の生産性を改善するための、パフォーマンス最適化技術を学びました。

- **健康診断**: `Flutter DevTools`を使い、FPSやメモリ使用量を監視する重要性を知りました。
- **`build`メソッドのコスト削減**:
  - `const`で作り置き部品を活用する。
  - `RepaintBoundary`で頻繁に動くWidgetを隔離する。
  - `setState`の影響範囲を小さくする。
- **リストの最適化**:
  - `ListView.builder`を徹底する。
  - `itemExtent`で高さを事前に教える。
- **遅延読み込み**: 必要になるまでデータや画像の読み込みを遅らせ、初期起動を高速化する。

パフォーマンス最適化は、地味ですが非常に奥が深い世界です。しかし、これらの基本的な原則を守るだけで、あなたの農場（アプリ）は、多くのユーザーにとって格段に快適な場所になるでしょう。
